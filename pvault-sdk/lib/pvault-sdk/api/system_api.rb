=begin
#Piiano Vault REST API

#--- sidebar_position: 1 sidebar_label: Overview description: The Piiano Vault REST API enables you to access and manage collections, objects, tokens, users, policies, and other resources within Piiano Vault. slug: / ---  # Introduction  The Piiano Vault REST API enables you to access and manage collections, objects, tokens, users, policies, and other resources within Piiano Vault in a simple, programmatic way using conventional HTTP requests and standard HTTP response codes.  The API follows RESTful conventions when possible, with most operations performed by `GET`, `POST`, `PUT`, `PATCH`, and `DELETE` requests. Request and response bodies are [JSON-encoded](https://www.json.org/json-en.html). However, for collection operations, an SQL-like [PVSchema](/guides/manage-collections-and-schemas/reference/pvschema) encoding is available.  This API reference provides details for each operation available in the API.  When you install a local copy of Vault, you can try each operation using **Send API request**.  An OpenAPI specification is available in [YAML](@site/static/assets/openapi.yaml) and [JSON](@site/static/assets/openapi.json) formats and can be used to generate client code for the API. 

The version of the OpenAPI document: 1.0

Generated by: https://openapi-generator.tech
OpenAPI Generator version: 6.3.0-SNAPSHOT

=end

require 'cgi'

module PvaultSdk
  class SystemApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Get control service health/status
    # Gets the status of the service.  The status codes returned follow the IETF standard [Health Check Response Format for HTTP APIs](https://datatracker.ietf.org/doc/html/draft-inadarei-api-health-check-05). For example, `pass` is returned when the service is up.
    # @param [Hash] opts the optional parameters
    # @return [Health]
    def control_health(opts = {})
      data, _status_code, _headers = control_health_with_http_info(opts)
      data
    end

    # Get control service health/status
    # Gets the status of the service.  The status codes returned follow the IETF standard [Health Check Response Format for HTTP APIs](https://datatracker.ietf.org/doc/html/draft-inadarei-api-health-check-05). For example, &#x60;pass&#x60; is returned when the service is up.
    # @param [Hash] opts the optional parameters
    # @return [Array<(Health, Integer, Hash)>] Health data, response status code and response headers
    def control_health_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemApi.control_health ...'
      end
      # resource path
      local_var_path = '/api/pvlt/1.0/ctl/info/health'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Health'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"SystemApi.control_health",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemApi#control_health\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get data service health/status
    # Gets the status of the service.  The status codes returned follow the IETF standard [Health Check Response Format for HTTP APIs](https://datatracker.ietf.org/doc/html/draft-inadarei-api-health-check-05). For example, `pass` is returned when the service is up.  The role performing this operation must have the `CapDataReader` capability. See [Access control](/data-security/identity-and-access-management#access-control) for more information about how capabilities are used to control access to operations.
    # @param [Hash] opts the optional parameters
    # @return [Health]
    def data_health(opts = {})
      data, _status_code, _headers = data_health_with_http_info(opts)
      data
    end

    # Get data service health/status
    # Gets the status of the service.  The status codes returned follow the IETF standard [Health Check Response Format for HTTP APIs](https://datatracker.ietf.org/doc/html/draft-inadarei-api-health-check-05). For example, &#x60;pass&#x60; is returned when the service is up.  The role performing this operation must have the &#x60;CapDataReader&#x60; capability. See [Access control](/data-security/identity-and-access-management#access-control) for more information about how capabilities are used to control access to operations.
    # @param [Hash] opts the optional parameters
    # @return [Array<(Health, Integer, Hash)>] Health data, response status code and response headers
    def data_health_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemApi.data_health ...'
      end
      # resource path
      local_var_path = '/api/pvlt/1.0/data/info/health'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Health'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"SystemApi.data_health",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemApi#data_health\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete objects and tokens
    # Deletes archived objects and tokens that have been archived for longer than the retention period.  See [Object life cycle](/data-privacy/object-lifecycle) for more information on how objects and tokens are archived and how deletion is affected by the retention period. 
    # @param reason [String] Details of the reason for requesting the property. The default is set when no access reason is provided and PVAULT_SERVICE_FORCE_ACCESS_REASON is false.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :filter Whether to delete objects, tokens, or both. Options are: - &#x60;objects_only&#x60; – delete only objects. - &#x60;tokens_only&#x60; – delete only tokens. If not set, the default is both. 
    # @option opts [Boolean] :dry_run Whether to respond with how many objects and tokens are available for deletion, without deleting them. (default to false)
    # @option opts [String] :adhoc_reason An ad-hoc reason for accessing the Vault data.
    # @option opts [Boolean] :reload_cache Reloads the cache before the action.
    # @return [Array<GcDeletionCount>]
    def garbage_collection(reason, opts = {})
      data, _status_code, _headers = garbage_collection_with_http_info(reason, opts)
      data
    end

    # Delete objects and tokens
    # Deletes archived objects and tokens that have been archived for longer than the retention period.  See [Object life cycle](/data-privacy/object-lifecycle) for more information on how objects and tokens are archived and how deletion is affected by the retention period. 
    # @param reason [String] Details of the reason for requesting the property. The default is set when no access reason is provided and PVAULT_SERVICE_FORCE_ACCESS_REASON is false.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :filter Whether to delete objects, tokens, or both. Options are: - &#x60;objects_only&#x60; – delete only objects. - &#x60;tokens_only&#x60; – delete only tokens. If not set, the default is both. 
    # @option opts [Boolean] :dry_run Whether to respond with how many objects and tokens are available for deletion, without deleting them. (default to false)
    # @option opts [String] :adhoc_reason An ad-hoc reason for accessing the Vault data.
    # @option opts [Boolean] :reload_cache Reloads the cache before the action.
    # @return [Array<(Array<GcDeletionCount>, Integer, Hash)>] Array<GcDeletionCount> data, response status code and response headers
    def garbage_collection_with_http_info(reason, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemApi.garbage_collection ...'
      end
      # verify the required parameter 'reason' is set
      if @api_client.config.client_side_validation && reason.nil?
        fail ArgumentError, "Missing the required parameter 'reason' when calling SystemApi.garbage_collection"
      end
      # verify enum value
      allowable_values = ["AppFunctionality", "Analytics", "Notifications", "Marketing", "ThirdPartyMarketing", "FraudPreventionSecurityAndCompliance", "AccountManagement", "Maintenance", "DataSubjectRequest", "Other"]
      if @api_client.config.client_side_validation && !allowable_values.include?(reason)
        fail ArgumentError, "invalid value for \"reason\", must be one of #{allowable_values}"
      end
      allowable_values = ["objects_only", "tokens_only"]
      if @api_client.config.client_side_validation && opts[:'filter'] && !allowable_values.include?(opts[:'filter'])
        fail ArgumentError, "invalid value for \"filter\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/api/pvlt/1.0/system/admin/lifecycle/gc'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'reason'] = reason
      query_params[:'filter'] = opts[:'filter'] if !opts[:'filter'].nil?
      query_params[:'dry_run'] = opts[:'dry_run'] if !opts[:'dry_run'].nil?
      query_params[:'adhoc_reason'] = opts[:'adhoc_reason'] if !opts[:'adhoc_reason'].nil?
      query_params[:'reload_cache'] = opts[:'reload_cache'] if !opts[:'reload_cache'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<GcDeletionCount>'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"SystemApi.garbage_collection",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemApi#garbage_collection\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get cluster information
    # Get Cluster Information.  Returns the vault's generation and the generations of all the workers (data servers).  The role that performs this operation must have the `CapClusterInfoReader` capability. See [Access control](/data-security/identity-and-access-management#access-control) for more information about how capabilities are used to control access to operations.
    # @param [Hash] opts the optional parameters
    # @return [AllGenerations]
    def get_cluster_info(opts = {})
      data, _status_code, _headers = get_cluster_info_with_http_info(opts)
      data
    end

    # Get cluster information
    # Get Cluster Information.  Returns the vault&#39;s generation and the generations of all the workers (data servers).  The role that performs this operation must have the &#x60;CapClusterInfoReader&#x60; capability. See [Access control](/data-security/identity-and-access-management#access-control) for more information about how capabilities are used to control access to operations.
    # @param [Hash] opts the optional parameters
    # @return [Array<(AllGenerations, Integer, Hash)>] AllGenerations data, response status code and response headers
    def get_cluster_info_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemApi.get_cluster_info ...'
      end
      # resource path
      local_var_path = '/api/pvlt/1.0/ctl/info/cluster'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'AllGenerations'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"SystemApi.get_cluster_info",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemApi#get_cluster_info\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get system configuration
    # Get the current active system configuration.  The role that performs this operation must have the `CapInfoReader` capability. See [Access control](/data-security/identity-and-access-management#access-control) for more information about how capabilities are used to control access to operations.
    # @param [Hash] opts the optional parameters
    # @return [ConfigConfig]
    def get_configuration(opts = {})
      data, _status_code, _headers = get_configuration_with_http_info(opts)
      data
    end

    # Get system configuration
    # Get the current active system configuration.  The role that performs this operation must have the &#x60;CapInfoReader&#x60; capability. See [Access control](/data-security/identity-and-access-management#access-control) for more information about how capabilities are used to control access to operations.
    # @param [Hash] opts the optional parameters
    # @return [Array<(ConfigConfig, Integer, Hash)>] ConfigConfig data, response status code and response headers
    def get_configuration_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemApi.get_configuration ...'
      end
      # resource path
      local_var_path = '/api/pvlt/1.0/system/info/configuration'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/toml', 'application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ConfigConfig'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"SystemApi.get_configuration",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemApi#get_configuration\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get KMS status
    # Gets the status of the configured KMS.  The role that performs this operation must have the `CapKMSReader` capability. See [Access control](/data-security/identity-and-access-management#access-control) for more information about how capabilities are used to control access to operations.
    # @param [Hash] opts the optional parameters
    # @return [KMSStatus]
    def get_kms(opts = {})
      data, _status_code, _headers = get_kms_with_http_info(opts)
      data
    end

    # Get KMS status
    # Gets the status of the configured KMS.  The role that performs this operation must have the &#x60;CapKMSReader&#x60; capability. See [Access control](/data-security/identity-and-access-management#access-control) for more information about how capabilities are used to control access to operations.
    # @param [Hash] opts the optional parameters
    # @return [Array<(KMSStatus, Integer, Hash)>] KMSStatus data, response status code and response headers
    def get_kms_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemApi.get_kms ...'
      end
      # resource path
      local_var_path = '/api/pvlt/1.0/system/info/kms'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'KMSStatus'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"SystemApi.get_kms",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemApi#get_kms\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get license
    # Gets information on the currently used license.  The role that performs this operation must have the `CapInfoReader` capability. See [Access control](/data-security/identity-and-access-management#access-control) for more information about how capabilities are used to control access to operations.
    # @param [Hash] opts the optional parameters
    # @return [License]
    def get_license(opts = {})
      data, _status_code, _headers = get_license_with_http_info(opts)
      data
    end

    # Get license
    # Gets information on the currently used license.  The role that performs this operation must have the &#x60;CapInfoReader&#x60; capability. See [Access control](/data-security/identity-and-access-management#access-control) for more information about how capabilities are used to control access to operations.
    # @param [Hash] opts the optional parameters
    # @return [Array<(License, Integer, Hash)>] License data, response status code and response headers
    def get_license_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemApi.get_license ...'
      end
      # resource path
      local_var_path = '/api/pvlt/1.0/system/info/license'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'License'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"SystemApi.get_license",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemApi#get_license\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get Vault version
    # Gets the version of Vault.
    # @param [Hash] opts the optional parameters
    # @return [ProductVersion]
    def get_vault_version(opts = {})
      data, _status_code, _headers = get_vault_version_with_http_info(opts)
      data
    end

    # Get Vault version
    # Gets the version of Vault.
    # @param [Hash] opts the optional parameters
    # @return [Array<(ProductVersion, Integer, Hash)>] ProductVersion data, response status code and response headers
    def get_vault_version_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemApi.get_vault_version ...'
      end
      # resource path
      local_var_path = '/api/pvlt/1.0/system/info/version'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ProductVersion'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"SystemApi.get_vault_version",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemApi#get_vault_version\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Rotate data encryption keys
    # Rotates all the KMS keys that Vault uses to encrypt properties, tokens, and more.  When the keys are rotated, new data is encrypted with the new key. All old keys are retained, so that content encrypted with previous keys can be decipherable.  The role that performs this operation must have the `CapKMSWriter` capability. See [Access control](/data-security/identity-and-access-management#access-control) for more information about how capabilities are used to control access to operations.
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def rotate_keys(opts = {})
      rotate_keys_with_http_info(opts)
      nil
    end

    # Rotate data encryption keys
    # Rotates all the KMS keys that Vault uses to encrypt properties, tokens, and more.  When the keys are rotated, new data is encrypted with the new key. All old keys are retained, so that content encrypted with previous keys can be decipherable.  The role that performs this operation must have the &#x60;CapKMSWriter&#x60; capability. See [Access control](/data-security/identity-and-access-management#access-control) for more information about how capabilities are used to control access to operations.
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def rotate_keys_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemApi.rotate_keys ...'
      end
      # resource path
      local_var_path = '/api/pvlt/1.0/system/admin/keys/rotate'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"SystemApi.rotate_keys",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemApi#rotate_keys\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Trigger an artificial error
    # Manually trigger an artificial error for testing purposes.  The role that performs this operation must have the `CapErrorWriter` capability. See [Access control](/data-security/identity-and-access-management#access-control) for more information about how capabilities are used to control access to operations.
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def trigger_error(opts = {})
      trigger_error_with_http_info(opts)
      nil
    end

    # Trigger an artificial error
    # Manually trigger an artificial error for testing purposes.  The role that performs this operation must have the &#x60;CapErrorWriter&#x60; capability. See [Access control](/data-security/identity-and-access-management#access-control) for more information about how capabilities are used to control access to operations.
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def trigger_error_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: SystemApi.trigger_error ...'
      end
      # resource path
      local_var_path = '/api/pvlt/1.0/system/debug/error/trigger'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"SystemApi.trigger_error",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: SystemApi#trigger_error\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
