=begin
#Piiano Vault REST API

#--- sidebar_position: 1 sidebar_label: Overview description: The Piiano Vault REST API enables you to access and manage collections, objects, tokens, users, policies, and other resources within Piiano Vault. slug: / ---  # Introduction  The Piiano Vault REST API enables you to access and manage collections, objects, tokens, users, policies, and other resources within Piiano Vault in a simple, programmatic way using conventional HTTP requests and standard HTTP response codes.  The API follows RESTful conventions when possible, with most operations performed by `GET`, `POST`, `PUT`, `PATCH`, and `DELETE` requests. Request and response bodies are [JSON-encoded](https://www.json.org/json-en.html). However, for collection operations, an SQL-like [PVSchema](/guides/manage-collections-and-schemas/reference/pvschema) encoding is available.  This API reference provides details for each operation available in the API.  When you install a local copy of Vault, you can try each operation using **Send API request**.  An OpenAPI specification is available in [YAML](@site/static/assets/openapi.yaml) and [JSON](@site/static/assets/openapi.json) formats and can be used to generate client code for the API. 

The version of the OpenAPI document: 1.0

Generated by: https://openapi-generator.tech
OpenAPI Generator version: 6.3.0-SNAPSHOT

=end

require 'cgi'

module PvaultSdk
  class TokensApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Delete tokens
    # Deletes tokens.  The tokens to delete are those that match all the criteria in the `token_ids`, `object_ids`,  and `tags` parameters. If the token query finds no matches, the operation returns a 404 error. See [search tokens](search-tokens) for more details.  The role performing this operation must have both of these: - The `CapTokensWriter` capability. - At least one allowing policy and no denying policies for the `delete` operation for the `tokens` resource of the specified collection.  See [identity and access management](/data-security/identity-and-access-management) for more information about how capabilities are used to control access to operations and policies are used to control access to data. 
    # @param collection [String] The name of the collection containing the objects.
    # @param reason [String] Details of the reason for requesting the property. The default is set when no access reason is provided and PVAULT_SERVICE_FORCE_ACCESS_REASON is false.
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :object_ids Comma-separated list of object IDs.
    # @option opts [Array<String>] :tags Comma-separated list of tags.
    # @option opts [Array<String>] :token_ids Comma-separated list of token IDs.
    # @option opts [Array<String>] :options Options for the operation. Options include: - &#x60;archived&#x60; – whether to delete only archived tokens. If not specified, delete only active tokens. 
    # @option opts [String] :adhoc_reason An ad-hoc reason for accessing the Vault data.
    # @option opts [Boolean] :reload_cache Reloads the cache before the action.
    # @return [nil]
    def delete_tokens(collection, reason, opts = {})
      delete_tokens_with_http_info(collection, reason, opts)
      nil
    end

    # Delete tokens
    # Deletes tokens.  The tokens to delete are those that match all the criteria in the &#x60;token_ids&#x60;, &#x60;object_ids&#x60;,  and &#x60;tags&#x60; parameters. If the token query finds no matches, the operation returns a 404 error. See [search tokens](search-tokens) for more details.  The role performing this operation must have both of these: - The &#x60;CapTokensWriter&#x60; capability. - At least one allowing policy and no denying policies for the &#x60;delete&#x60; operation for the &#x60;tokens&#x60; resource of the specified collection.  See [identity and access management](/data-security/identity-and-access-management) for more information about how capabilities are used to control access to operations and policies are used to control access to data. 
    # @param collection [String] The name of the collection containing the objects.
    # @param reason [String] Details of the reason for requesting the property. The default is set when no access reason is provided and PVAULT_SERVICE_FORCE_ACCESS_REASON is false.
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :object_ids Comma-separated list of object IDs.
    # @option opts [Array<String>] :tags Comma-separated list of tags.
    # @option opts [Array<String>] :token_ids Comma-separated list of token IDs.
    # @option opts [Array<String>] :options Options for the operation. Options include: - &#x60;archived&#x60; – whether to delete only archived tokens. If not specified, delete only active tokens. 
    # @option opts [String] :adhoc_reason An ad-hoc reason for accessing the Vault data.
    # @option opts [Boolean] :reload_cache Reloads the cache before the action.
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def delete_tokens_with_http_info(collection, reason, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TokensApi.delete_tokens ...'
      end
      # verify the required parameter 'collection' is set
      if @api_client.config.client_side_validation && collection.nil?
        fail ArgumentError, "Missing the required parameter 'collection' when calling TokensApi.delete_tokens"
      end
      pattern = Regexp.new(/^[a-zA-Z][a-zA-Z0-9_]*$/)
      if @api_client.config.client_side_validation && collection !~ pattern
        fail ArgumentError, "invalid value for 'collection' when calling TokensApi.delete_tokens, must conform to the pattern #{pattern}."
      end

      # verify the required parameter 'reason' is set
      if @api_client.config.client_side_validation && reason.nil?
        fail ArgumentError, "Missing the required parameter 'reason' when calling TokensApi.delete_tokens"
      end
      # verify enum value
      allowable_values = ["AppFunctionality", "Analytics", "Notifications", "Marketing", "ThirdPartyMarketing", "FraudPreventionSecurityAndCompliance", "AccountManagement", "Maintenance", "DataSubjectRequest", "Other"]
      if @api_client.config.client_side_validation && !allowable_values.include?(reason)
        fail ArgumentError, "invalid value for \"reason\", must be one of #{allowable_values}"
      end
      allowable_values = ["archived"]
      if @api_client.config.client_side_validation && opts[:'options'] && !opts[:'options'].all? { |item| allowable_values.include?(item) }
        fail ArgumentError, "invalid value for \"options\", must include one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/api/pvlt/1.0/data/collections/{collection}/tokens'.sub('{' + 'collection' + '}', CGI.escape(collection.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'reason'] = reason
      query_params[:'object_ids'] = @api_client.build_collection_param(opts[:'object_ids'], :multi) if !opts[:'object_ids'].nil?
      query_params[:'tags'] = @api_client.build_collection_param(opts[:'tags'], :multi) if !opts[:'tags'].nil?
      query_params[:'token_ids'] = @api_client.build_collection_param(opts[:'token_ids'], :multi) if !opts[:'token_ids'].nil?
      query_params[:'options'] = @api_client.build_collection_param(opts[:'options'], :multi) if !opts[:'options'].nil?
      query_params[:'adhoc_reason'] = opts[:'adhoc_reason'] if !opts[:'adhoc_reason'].nil?
      query_params[:'reload_cache'] = opts[:'reload_cache'] if !opts[:'reload_cache'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"TokensApi.delete_tokens",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TokensApi#delete_tokens\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Detokenize tokens
    # Returns the object property values for tokens.  The tokens returned by this operation are defined using three query parameters: `token_ids`, `object_ids`, and `tags`. If the token query includes an invalid or not found token ID, the operation returns a 404 status code. Otherwise, the operation returns an empty response if it finds no matches. See the [Retrieve a token](/guides/tokenize-personal-data/retrieve-a-token) guide for more information about how to match tokens for this operation.  The role performing this operation must have all of these: - The `CapTokensDetokenizer` capability. - Policies:   + At least one allowing policy and no denying policies for the `detokenize` operation for each of the collection properties that are tokenized by tokens specified in the query.   + At least one allowing policy and no denying policies for the `read` operation for each of the collection properties that are tokenized by tokens specified in the query.  See [identity and access management](/data-security/identity-and-access-management) for more information about how capabilities are used to control access to operations and policies are used to control access to data. 
    # @param collection [String] The name of the collection containing the objects.
    # @param reason [String] Details of the reason for requesting the property. The default is set when no access reason is provided and PVAULT_SERVICE_FORCE_ACCESS_REASON is false.
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :object_ids Comma-separated list of object IDs.
    # @option opts [Array<String>] :options Options for the operation. Options include: - &#x60;include_metadata&#x60; - show token metadata in the response. 
    # @option opts [Array<String>] :tags Comma-separated list of tags.
    # @option opts [Array<String>] :token_ids Comma-separated list of token IDs.
    # @option opts [String] :adhoc_reason An ad-hoc reason for accessing the Vault data.
    # @option opts [Boolean] :reload_cache Reloads the cache before the action.
    # @return [Array<DetokenizedToken>]
    def detokenize(collection, reason, opts = {})
      data, _status_code, _headers = detokenize_with_http_info(collection, reason, opts)
      data
    end

    # Detokenize tokens
    # Returns the object property values for tokens.  The tokens returned by this operation are defined using three query parameters: &#x60;token_ids&#x60;, &#x60;object_ids&#x60;, and &#x60;tags&#x60;. If the token query includes an invalid or not found token ID, the operation returns a 404 status code. Otherwise, the operation returns an empty response if it finds no matches. See the [Retrieve a token](/guides/tokenize-personal-data/retrieve-a-token) guide for more information about how to match tokens for this operation.  The role performing this operation must have all of these: - The &#x60;CapTokensDetokenizer&#x60; capability. - Policies:   + At least one allowing policy and no denying policies for the &#x60;detokenize&#x60; operation for each of the collection properties that are tokenized by tokens specified in the query.   + At least one allowing policy and no denying policies for the &#x60;read&#x60; operation for each of the collection properties that are tokenized by tokens specified in the query.  See [identity and access management](/data-security/identity-and-access-management) for more information about how capabilities are used to control access to operations and policies are used to control access to data. 
    # @param collection [String] The name of the collection containing the objects.
    # @param reason [String] Details of the reason for requesting the property. The default is set when no access reason is provided and PVAULT_SERVICE_FORCE_ACCESS_REASON is false.
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :object_ids Comma-separated list of object IDs.
    # @option opts [Array<String>] :options Options for the operation. Options include: - &#x60;include_metadata&#x60; - show token metadata in the response. 
    # @option opts [Array<String>] :tags Comma-separated list of tags.
    # @option opts [Array<String>] :token_ids Comma-separated list of token IDs.
    # @option opts [String] :adhoc_reason An ad-hoc reason for accessing the Vault data.
    # @option opts [Boolean] :reload_cache Reloads the cache before the action.
    # @return [Array<(Array<DetokenizedToken>, Integer, Hash)>] Array<DetokenizedToken> data, response status code and response headers
    def detokenize_with_http_info(collection, reason, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TokensApi.detokenize ...'
      end
      # verify the required parameter 'collection' is set
      if @api_client.config.client_side_validation && collection.nil?
        fail ArgumentError, "Missing the required parameter 'collection' when calling TokensApi.detokenize"
      end
      pattern = Regexp.new(/^[a-zA-Z][a-zA-Z0-9_]*$/)
      if @api_client.config.client_side_validation && collection !~ pattern
        fail ArgumentError, "invalid value for 'collection' when calling TokensApi.detokenize, must conform to the pattern #{pattern}."
      end

      # verify the required parameter 'reason' is set
      if @api_client.config.client_side_validation && reason.nil?
        fail ArgumentError, "Missing the required parameter 'reason' when calling TokensApi.detokenize"
      end
      # verify enum value
      allowable_values = ["AppFunctionality", "Analytics", "Notifications", "Marketing", "ThirdPartyMarketing", "FraudPreventionSecurityAndCompliance", "AccountManagement", "Maintenance", "DataSubjectRequest", "Other"]
      if @api_client.config.client_side_validation && !allowable_values.include?(reason)
        fail ArgumentError, "invalid value for \"reason\", must be one of #{allowable_values}"
      end
      allowable_values = ["include_metadata"]
      if @api_client.config.client_side_validation && opts[:'options'] && !opts[:'options'].all? { |item| allowable_values.include?(item) }
        fail ArgumentError, "invalid value for \"options\", must include one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/api/pvlt/1.0/data/collections/{collection}/tokens'.sub('{' + 'collection' + '}', CGI.escape(collection.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'reason'] = reason
      query_params[:'object_ids'] = @api_client.build_collection_param(opts[:'object_ids'], :multi) if !opts[:'object_ids'].nil?
      query_params[:'options'] = @api_client.build_collection_param(opts[:'options'], :multi) if !opts[:'options'].nil?
      query_params[:'tags'] = @api_client.build_collection_param(opts[:'tags'], :multi) if !opts[:'tags'].nil?
      query_params[:'token_ids'] = @api_client.build_collection_param(opts[:'token_ids'], :multi) if !opts[:'token_ids'].nil?
      query_params[:'adhoc_reason'] = opts[:'adhoc_reason'] if !opts[:'adhoc_reason'].nil?
      query_params[:'reload_cache'] = opts[:'reload_cache'] if !opts[:'reload_cache'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Array<DetokenizedToken>'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"TokensApi.detokenize",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TokensApi#detokenize\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Rotate tokens
    # Generates new token IDs for a list of tokens.  The role performing this operation must have both of these: - The `CapTokensWriter` capability. - At least one allowing policy and no denying policies for the `write` operation for the `tokens` resource of the specified collection.  See [identity and access management](/data-security/identity-and-access-management) for more information about how capabilities are used to control access to operations and policies are used to control access to data. 
    # @param token_ids [Array<String>] Comma-separated list of token IDs.
    # @param collection [String] The name of the collection containing the objects.
    # @param reason [String] Details of the reason for requesting the property. The default is set when no access reason is provided and PVAULT_SERVICE_FORCE_ACCESS_REASON is false.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :adhoc_reason An ad-hoc reason for accessing the Vault data.
    # @option opts [Boolean] :reload_cache Reloads the cache before the action.
    # @return [Hash<String, String>]
    def rotate_tokens(token_ids, collection, reason, opts = {})
      data, _status_code, _headers = rotate_tokens_with_http_info(token_ids, collection, reason, opts)
      data
    end

    # Rotate tokens
    # Generates new token IDs for a list of tokens.  The role performing this operation must have both of these: - The &#x60;CapTokensWriter&#x60; capability. - At least one allowing policy and no denying policies for the &#x60;write&#x60; operation for the &#x60;tokens&#x60; resource of the specified collection.  See [identity and access management](/data-security/identity-and-access-management) for more information about how capabilities are used to control access to operations and policies are used to control access to data. 
    # @param token_ids [Array<String>] Comma-separated list of token IDs.
    # @param collection [String] The name of the collection containing the objects.
    # @param reason [String] Details of the reason for requesting the property. The default is set when no access reason is provided and PVAULT_SERVICE_FORCE_ACCESS_REASON is false.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :adhoc_reason An ad-hoc reason for accessing the Vault data.
    # @option opts [Boolean] :reload_cache Reloads the cache before the action.
    # @return [Array<(Hash<String, String>, Integer, Hash)>] Hash<String, String> data, response status code and response headers
    def rotate_tokens_with_http_info(token_ids, collection, reason, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TokensApi.rotate_tokens ...'
      end
      # verify the required parameter 'token_ids' is set
      if @api_client.config.client_side_validation && token_ids.nil?
        fail ArgumentError, "Missing the required parameter 'token_ids' when calling TokensApi.rotate_tokens"
      end
      # verify the required parameter 'collection' is set
      if @api_client.config.client_side_validation && collection.nil?
        fail ArgumentError, "Missing the required parameter 'collection' when calling TokensApi.rotate_tokens"
      end
      pattern = Regexp.new(/^[a-zA-Z][a-zA-Z0-9_]*$/)
      if @api_client.config.client_side_validation && collection !~ pattern
        fail ArgumentError, "invalid value for 'collection' when calling TokensApi.rotate_tokens, must conform to the pattern #{pattern}."
      end

      # verify the required parameter 'reason' is set
      if @api_client.config.client_side_validation && reason.nil?
        fail ArgumentError, "Missing the required parameter 'reason' when calling TokensApi.rotate_tokens"
      end
      # verify enum value
      allowable_values = ["AppFunctionality", "Analytics", "Notifications", "Marketing", "ThirdPartyMarketing", "FraudPreventionSecurityAndCompliance", "AccountManagement", "Maintenance", "DataSubjectRequest", "Other"]
      if @api_client.config.client_side_validation && !allowable_values.include?(reason)
        fail ArgumentError, "invalid value for \"reason\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/api/pvlt/1.0/data/collections/{collection}/rotate/tokens'.sub('{' + 'collection' + '}', CGI.escape(collection.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'token_ids'] = @api_client.build_collection_param(token_ids, :multi)
      query_params[:'reason'] = reason
      query_params[:'adhoc_reason'] = opts[:'adhoc_reason'] if !opts[:'adhoc_reason'].nil?
      query_params[:'reload_cache'] = opts[:'reload_cache'] if !opts[:'reload_cache'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Hash<String, String>'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"TokensApi.rotate_tokens",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TokensApi#rotate_tokens\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Search tokens
    # Lists tokens with their metadata.   If the token query includes an invalid or not found token ID, the operation returns a 404 error. Otherwise, if no matches are found, the operation returns an empty response.   The role performing this operation must have all of these: - The `CapTokensReader` capability. - At least one allowing policy and no denying policies for the `read` operation for the `tokens` resource of the specified collection.  See [identity and access management](/data-security/identity-and-access-management) for more information about how capabilities are used to control access to operations and policies are used to control access to data.  The tokens returned by this operation are defined using three query parameters: `token_ids`, `object_ids`, and `tags`. If the token query includes an invalid or not found token ID, the operation returns a 404 status code. Otherwise, the operation returns an empty response if it finds no matches. See the [Retrieve a token](/guides/tokenize-personal-data/retrieve-a-token) guide for more information about how to match tokens for this operation.  
    # @param collection [String] The name of the collection containing the objects.
    # @param reason [String] Details of the reason for requesting the property. The default is set when no access reason is provided and PVAULT_SERVICE_FORCE_ACCESS_REASON is false.
    # @param query_token [QueryToken] The token query.
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :options Options for the operation. Options include: - &#x60;archived&#x60; – whether to search only archived tokens. If not specified, search only active tokens. 
    # @option opts [String] :adhoc_reason An ad-hoc reason for accessing the Vault data.
    # @option opts [Boolean] :reload_cache Reloads the cache before the action.
    # @return [Array<TokenMetadata>]
    def search_tokens(collection, reason, query_token, opts = {})
      data, _status_code, _headers = search_tokens_with_http_info(collection, reason, query_token, opts)
      data
    end

    # Search tokens
    # Lists tokens with their metadata.   If the token query includes an invalid or not found token ID, the operation returns a 404 error. Otherwise, if no matches are found, the operation returns an empty response.   The role performing this operation must have all of these: - The &#x60;CapTokensReader&#x60; capability. - At least one allowing policy and no denying policies for the &#x60;read&#x60; operation for the &#x60;tokens&#x60; resource of the specified collection.  See [identity and access management](/data-security/identity-and-access-management) for more information about how capabilities are used to control access to operations and policies are used to control access to data.  The tokens returned by this operation are defined using three query parameters: &#x60;token_ids&#x60;, &#x60;object_ids&#x60;, and &#x60;tags&#x60;. If the token query includes an invalid or not found token ID, the operation returns a 404 status code. Otherwise, the operation returns an empty response if it finds no matches. See the [Retrieve a token](/guides/tokenize-personal-data/retrieve-a-token) guide for more information about how to match tokens for this operation.  
    # @param collection [String] The name of the collection containing the objects.
    # @param reason [String] Details of the reason for requesting the property. The default is set when no access reason is provided and PVAULT_SERVICE_FORCE_ACCESS_REASON is false.
    # @param query_token [QueryToken] The token query.
    # @param [Hash] opts the optional parameters
    # @option opts [Array<String>] :options Options for the operation. Options include: - &#x60;archived&#x60; – whether to search only archived tokens. If not specified, search only active tokens. 
    # @option opts [String] :adhoc_reason An ad-hoc reason for accessing the Vault data.
    # @option opts [Boolean] :reload_cache Reloads the cache before the action.
    # @return [Array<(Array<TokenMetadata>, Integer, Hash)>] Array<TokenMetadata> data, response status code and response headers
    def search_tokens_with_http_info(collection, reason, query_token, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TokensApi.search_tokens ...'
      end
      # verify the required parameter 'collection' is set
      if @api_client.config.client_side_validation && collection.nil?
        fail ArgumentError, "Missing the required parameter 'collection' when calling TokensApi.search_tokens"
      end
      pattern = Regexp.new(/^[a-zA-Z][a-zA-Z0-9_]*$/)
      if @api_client.config.client_side_validation && collection !~ pattern
        fail ArgumentError, "invalid value for 'collection' when calling TokensApi.search_tokens, must conform to the pattern #{pattern}."
      end

      # verify the required parameter 'reason' is set
      if @api_client.config.client_side_validation && reason.nil?
        fail ArgumentError, "Missing the required parameter 'reason' when calling TokensApi.search_tokens"
      end
      # verify enum value
      allowable_values = ["AppFunctionality", "Analytics", "Notifications", "Marketing", "ThirdPartyMarketing", "FraudPreventionSecurityAndCompliance", "AccountManagement", "Maintenance", "DataSubjectRequest", "Other"]
      if @api_client.config.client_side_validation && !allowable_values.include?(reason)
        fail ArgumentError, "invalid value for \"reason\", must be one of #{allowable_values}"
      end
      # verify the required parameter 'query_token' is set
      if @api_client.config.client_side_validation && query_token.nil?
        fail ArgumentError, "Missing the required parameter 'query_token' when calling TokensApi.search_tokens"
      end
      allowable_values = ["archived"]
      if @api_client.config.client_side_validation && opts[:'options'] && !opts[:'options'].all? { |item| allowable_values.include?(item) }
        fail ArgumentError, "invalid value for \"options\", must include one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/api/pvlt/1.0/data/collections/{collection}/query/tokens'.sub('{' + 'collection' + '}', CGI.escape(collection.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'reason'] = reason
      query_params[:'options'] = @api_client.build_collection_param(opts[:'options'], :multi) if !opts[:'options'].nil?
      query_params[:'adhoc_reason'] = opts[:'adhoc_reason'] if !opts[:'adhoc_reason'].nil?
      query_params[:'reload_cache'] = opts[:'reload_cache'] if !opts[:'reload_cache'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(query_token)

      # return_type
      return_type = opts[:debug_return_type] || 'Array<TokenMetadata>'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"TokensApi.search_tokens",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TokensApi#search_tokens\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Tokenize
    # Creates tokens that reference the values of objects' properties. The token ID is partially or wholly randomly-generated and, therefore, is not sensitive.  The returned token IDs are in the same order as the object IDs in the request. No tokens are created if any object IDs are invalid or not found.  If this operation is called for an object ID and properties that have a token: - Any token tags are appended to the existing token. - If an expiration is specified, then the token expiry is updated. If an expiration is not specified, the token expiry is updated if the default settings result in an expiry date after the token's current expiry date.  The role performing this operation must have both of these: - The `CapTokensWriter` capability. - At least one allowing policy and no denying policies for the `tokenize` operation for each of the collection properties specified in the call.  See [identity and access management](/data-security/identity-and-access-management) for more information about how capabilities are used to control access to operations and policies are used to control access to data. 
    # @param collection [String] The name of the collection containing the objects.
    # @param reason [String] Details of the reason for requesting the property. The default is set when no access reason is provided and PVAULT_SERVICE_FORCE_ACCESS_REASON is false.
    # @param tokenize_request [Array<TokenizeRequest>] Details of the tokenization request.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :expiration_secs Token expiration time in seconds. If not set, the default expiration time is used. See the &#x60;PVAULT_EXPIRATION_TOKENS&#x60; variable.
    # @option opts [String] :adhoc_reason An ad-hoc reason for accessing the Vault data.
    # @option opts [Boolean] :reload_cache Reloads the cache before the action.
    # @return [Array<TokenValue>]
    def tokenize(collection, reason, tokenize_request, opts = {})
      data, _status_code, _headers = tokenize_with_http_info(collection, reason, tokenize_request, opts)
      data
    end

    # Tokenize
    # Creates tokens that reference the values of objects&#39; properties. The token ID is partially or wholly randomly-generated and, therefore, is not sensitive.  The returned token IDs are in the same order as the object IDs in the request. No tokens are created if any object IDs are invalid or not found.  If this operation is called for an object ID and properties that have a token: - Any token tags are appended to the existing token. - If an expiration is specified, then the token expiry is updated. If an expiration is not specified, the token expiry is updated if the default settings result in an expiry date after the token&#39;s current expiry date.  The role performing this operation must have both of these: - The &#x60;CapTokensWriter&#x60; capability. - At least one allowing policy and no denying policies for the &#x60;tokenize&#x60; operation for each of the collection properties specified in the call.  See [identity and access management](/data-security/identity-and-access-management) for more information about how capabilities are used to control access to operations and policies are used to control access to data. 
    # @param collection [String] The name of the collection containing the objects.
    # @param reason [String] Details of the reason for requesting the property. The default is set when no access reason is provided and PVAULT_SERVICE_FORCE_ACCESS_REASON is false.
    # @param tokenize_request [Array<TokenizeRequest>] Details of the tokenization request.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :expiration_secs Token expiration time in seconds. If not set, the default expiration time is used. See the &#x60;PVAULT_EXPIRATION_TOKENS&#x60; variable.
    # @option opts [String] :adhoc_reason An ad-hoc reason for accessing the Vault data.
    # @option opts [Boolean] :reload_cache Reloads the cache before the action.
    # @return [Array<(Array<TokenValue>, Integer, Hash)>] Array<TokenValue> data, response status code and response headers
    def tokenize_with_http_info(collection, reason, tokenize_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TokensApi.tokenize ...'
      end
      # verify the required parameter 'collection' is set
      if @api_client.config.client_side_validation && collection.nil?
        fail ArgumentError, "Missing the required parameter 'collection' when calling TokensApi.tokenize"
      end
      pattern = Regexp.new(/^[a-zA-Z][a-zA-Z0-9_]*$/)
      if @api_client.config.client_side_validation && collection !~ pattern
        fail ArgumentError, "invalid value for 'collection' when calling TokensApi.tokenize, must conform to the pattern #{pattern}."
      end

      # verify the required parameter 'reason' is set
      if @api_client.config.client_side_validation && reason.nil?
        fail ArgumentError, "Missing the required parameter 'reason' when calling TokensApi.tokenize"
      end
      # verify enum value
      allowable_values = ["AppFunctionality", "Analytics", "Notifications", "Marketing", "ThirdPartyMarketing", "FraudPreventionSecurityAndCompliance", "AccountManagement", "Maintenance", "DataSubjectRequest", "Other"]
      if @api_client.config.client_side_validation && !allowable_values.include?(reason)
        fail ArgumentError, "invalid value for \"reason\", must be one of #{allowable_values}"
      end
      # verify the required parameter 'tokenize_request' is set
      if @api_client.config.client_side_validation && tokenize_request.nil?
        fail ArgumentError, "Missing the required parameter 'tokenize_request' when calling TokensApi.tokenize"
      end
      pattern = Regexp.new(/^[0-9]*$/)
      if @api_client.config.client_side_validation && !opts[:'expiration_secs'].nil? && opts[:'expiration_secs'] !~ pattern
        fail ArgumentError, "invalid value for 'opts[:\"expiration_secs\"]' when calling TokensApi.tokenize, must conform to the pattern #{pattern}."
      end

      # resource path
      local_var_path = '/api/pvlt/1.0/data/collections/{collection}/tokens'.sub('{' + 'collection' + '}', CGI.escape(collection.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'reason'] = reason
      query_params[:'expiration_secs'] = opts[:'expiration_secs'] if !opts[:'expiration_secs'].nil?
      query_params[:'adhoc_reason'] = opts[:'adhoc_reason'] if !opts[:'adhoc_reason'].nil?
      query_params[:'reload_cache'] = opts[:'reload_cache'] if !opts[:'reload_cache'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(tokenize_request)

      # return_type
      return_type = opts[:debug_return_type] || 'Array<TokenValue>'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"TokensApi.tokenize",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TokensApi#tokenize\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update tokens
    # Updates `tags` and `expiration` token metadata.  The role performing this operation must have both of these: - The `CapTokensWriter` capability. - At least one allowing policy and no denying policies for the `write` operation for the `tokens` resource of the collection specified in the call.  See [identity and access management](/data-security/identity-and-access-management) for more information about how capabilities are used to control access to operations and policies are used to control access to data.  The tokens returned by this operation are defined using three query parameters: `token_ids`, `object_ids`, and `tags`. If no tokens are matched, status code 404 is returned. See the [Retrieve a token](/guides/tokenize-personal-data/retrieve-a-token) guide for more information about how to match tokens for this operation. 
    # @param collection [String] The name of the collection containing the objects.
    # @param reason [String] Details of the reason for requesting the property. The default is set when no access reason is provided and PVAULT_SERVICE_FORCE_ACCESS_REASON is false.
    # @param update_token_request [UpdateTokenRequest] Update token request details.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :expiration_secs Expiration time in seconds for the tokens. If not set, the expiry dates of the tokens are not changed.
    # @option opts [Array<String>] :object_ids Comma-separated list of object IDs.
    # @option opts [Array<String>] :tags Comma-separated list of tags.
    # @option opts [Array<String>] :token_ids Comma-separated list of token IDs.
    # @option opts [Array<String>] :options Options for the operation. Options include: - &#x60;archived&#x60; – whether to update only archived tokens. If not specified, update only active tokens. 
    # @option opts [String] :adhoc_reason An ad-hoc reason for accessing the Vault data.
    # @option opts [Boolean] :reload_cache Reloads the cache before the action.
    # @return [nil]
    def update_tokens(collection, reason, update_token_request, opts = {})
      update_tokens_with_http_info(collection, reason, update_token_request, opts)
      nil
    end

    # Update tokens
    # Updates &#x60;tags&#x60; and &#x60;expiration&#x60; token metadata.  The role performing this operation must have both of these: - The &#x60;CapTokensWriter&#x60; capability. - At least one allowing policy and no denying policies for the &#x60;write&#x60; operation for the &#x60;tokens&#x60; resource of the collection specified in the call.  See [identity and access management](/data-security/identity-and-access-management) for more information about how capabilities are used to control access to operations and policies are used to control access to data.  The tokens returned by this operation are defined using three query parameters: &#x60;token_ids&#x60;, &#x60;object_ids&#x60;, and &#x60;tags&#x60;. If no tokens are matched, status code 404 is returned. See the [Retrieve a token](/guides/tokenize-personal-data/retrieve-a-token) guide for more information about how to match tokens for this operation. 
    # @param collection [String] The name of the collection containing the objects.
    # @param reason [String] Details of the reason for requesting the property. The default is set when no access reason is provided and PVAULT_SERVICE_FORCE_ACCESS_REASON is false.
    # @param update_token_request [UpdateTokenRequest] Update token request details.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :expiration_secs Expiration time in seconds for the tokens. If not set, the expiry dates of the tokens are not changed.
    # @option opts [Array<String>] :object_ids Comma-separated list of object IDs.
    # @option opts [Array<String>] :tags Comma-separated list of tags.
    # @option opts [Array<String>] :token_ids Comma-separated list of token IDs.
    # @option opts [Array<String>] :options Options for the operation. Options include: - &#x60;archived&#x60; – whether to update only archived tokens. If not specified, update only active tokens. 
    # @option opts [String] :adhoc_reason An ad-hoc reason for accessing the Vault data.
    # @option opts [Boolean] :reload_cache Reloads the cache before the action.
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def update_tokens_with_http_info(collection, reason, update_token_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TokensApi.update_tokens ...'
      end
      # verify the required parameter 'collection' is set
      if @api_client.config.client_side_validation && collection.nil?
        fail ArgumentError, "Missing the required parameter 'collection' when calling TokensApi.update_tokens"
      end
      pattern = Regexp.new(/^[a-zA-Z][a-zA-Z0-9_]*$/)
      if @api_client.config.client_side_validation && collection !~ pattern
        fail ArgumentError, "invalid value for 'collection' when calling TokensApi.update_tokens, must conform to the pattern #{pattern}."
      end

      # verify the required parameter 'reason' is set
      if @api_client.config.client_side_validation && reason.nil?
        fail ArgumentError, "Missing the required parameter 'reason' when calling TokensApi.update_tokens"
      end
      # verify enum value
      allowable_values = ["AppFunctionality", "Analytics", "Notifications", "Marketing", "ThirdPartyMarketing", "FraudPreventionSecurityAndCompliance", "AccountManagement", "Maintenance", "DataSubjectRequest", "Other"]
      if @api_client.config.client_side_validation && !allowable_values.include?(reason)
        fail ArgumentError, "invalid value for \"reason\", must be one of #{allowable_values}"
      end
      # verify the required parameter 'update_token_request' is set
      if @api_client.config.client_side_validation && update_token_request.nil?
        fail ArgumentError, "Missing the required parameter 'update_token_request' when calling TokensApi.update_tokens"
      end
      pattern = Regexp.new(/^[0-9]*$/)
      if @api_client.config.client_side_validation && !opts[:'expiration_secs'].nil? && opts[:'expiration_secs'] !~ pattern
        fail ArgumentError, "invalid value for 'opts[:\"expiration_secs\"]' when calling TokensApi.update_tokens, must conform to the pattern #{pattern}."
      end

      allowable_values = ["archived"]
      if @api_client.config.client_side_validation && opts[:'options'] && !opts[:'options'].all? { |item| allowable_values.include?(item) }
        fail ArgumentError, "invalid value for \"options\", must include one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/api/pvlt/1.0/data/collections/{collection}/tokens'.sub('{' + 'collection' + '}', CGI.escape(collection.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'reason'] = reason
      query_params[:'expiration_secs'] = opts[:'expiration_secs'] if !opts[:'expiration_secs'].nil?
      query_params[:'object_ids'] = @api_client.build_collection_param(opts[:'object_ids'], :multi) if !opts[:'object_ids'].nil?
      query_params[:'tags'] = @api_client.build_collection_param(opts[:'tags'], :multi) if !opts[:'tags'].nil?
      query_params[:'token_ids'] = @api_client.build_collection_param(opts[:'token_ids'], :multi) if !opts[:'token_ids'].nil?
      query_params[:'options'] = @api_client.build_collection_param(opts[:'options'], :multi) if !opts[:'options'].nil?
      query_params[:'adhoc_reason'] = opts[:'adhoc_reason'] if !opts[:'adhoc_reason'].nil?
      query_params[:'reload_cache'] = opts[:'reload_cache'] if !opts[:'reload_cache'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(update_token_request)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['bearerAuth']

      new_options = opts.merge(
        :operation => :"TokensApi.update_tokens",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TokensApi#update_tokens\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
